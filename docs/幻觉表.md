## 一、从 CK3 / EU4 偷来的、已经被打脸的东西

### 1.1 `character_event` 事件类型

**幻觉：**

一开始沿用 CK3/EU4 习惯，脑补有 `character_event`，甚至用“角色事件”来描述五星展示。

**现实：**

EU5 Event 文档列出来的类型里没有 `character_event`，只有 `country_event` / `location_event` / `unit_event` / `exploration_event` 等。

现在我们已经统一改成 `type = country_event`，靠 saved scope / illustration 做立绘。

---

### 1.2 `character = scope:xxx` 绑定立绘

**幻觉：**

V3 文档里最早写的是：

<pre class="overflow-visible!" data-start="504" data-end="571"><div class="contain-inline-size rounded-2xl relative bg-token-sidebar-surface-primary"><div class="sticky top-9"><div class="absolute end-0 bottom-0 flex h-9 items-center pe-2"><div class="bg-token-bg-elevated-secondary text-token-text-secondary flex items-center gap-4 rounded-sm px-2 font-sans text-xs"></div></div></div><div class="overflow-y-auto p-4" dir="ltr"><code class="whitespace-pre! language-txt"><span><span># 【UI Binding】
character = scope:gacha_event_target_char
</span></span></code></div></div></pre>

这是 CK3 的老语法。

**现实：**

EU5 用的是  **illustration 系统** ，Event 文档强调的是：

* 事件图由 illustration 驱动；
* 对于 pops，前两个 saved pop scope 会用来画图；
* 可以用 `event_illustration_XXX_effect`、`image = "...dds"` 等方式控制。

没有任何地方提 `character = scope:xxx` 这种字段。我们后面已经改成：

* 在 `immediate` 里 `save_scope_as = gacha_event_target_char`；
* 让 UI 通过 illustration / saved scope 机制拿角色，而不是靠 `character =`。

**结论：**

`character = scope:xxx` 属于纯 CK3 幻觉，已经从设计中删掉。

---

### 1.3 `is_triggered_only` 之类的老字段

**幻觉：**

一开始提过“用 is_triggered_only 避免随机触发”，这是 EU4/EU3 时代的遗留思路。

**现实：**

EU5 Event 文档中事件控制靠：

* `trigger = { ... }`
* 挂 / 不挂 on_action
* `mean_time_to_happen` 等等

没有 `is_triggered_only` 这个字段。

**结论：**

“不要随机触发”在 EU5 里就是 **不要挂到任何随机 on_action** ，或者 `trigger = { always = no }`，不需要 `is_triggered_only`。

---

## 二、变量访问相关的幻觉

这块是你实际踩 log 的地方，集中在：`var:`/`local_var:` 用法、以及 where/when 初始化。

### 2.1 在 script_value 中乱用 `var:` / `local_var:`

**幻觉：**

<pre class="overflow-visible!" data-start="1487" data-end="1597"><div class="contain-inline-size rounded-2xl relative bg-token-sidebar-surface-primary"><div class="sticky top-9"><div class="absolute end-0 bottom-0 flex h-9 items-center pe-2"><div class="bg-token-bg-elevated-secondary text-token-text-secondary flex items-center gap-4 rounded-sm px-2 font-sans text-xs"></div></div></div><div class="overflow-y-auto p-4" dir="ltr"><code class="whitespace-pre! language-txt"><span><span>gacha_calc_entropy_sv = {
    add = { value = var:gacha_total_rolls_count multiply = 17 }
    ...
}
</span></span></code></div></div></pre>

以及在各种 trigger 里写：

<pre class="overflow-visible!" data-start="1618" data-end="1673"><div class="contain-inline-size rounded-2xl relative bg-token-sidebar-surface-primary"><div class="sticky top-9"><div class="absolute end-0 bottom-0 flex h-9 items-center pe-2"><div class="bg-token-bg-elevated-secondary text-token-text-secondary flex items-center gap-4 rounded-sm px-2 font-sans text-xs"></div></div></div><div class="overflow-y-auto p-4" dir="ltr"><code class="whitespace-pre! language-txt"><span><span>limit = { var:gacha_constellation_lvl >= 6 }
</span></span></code></div></div></pre>

这个写法混合了 HOI4 / Vic3 的记忆 + 自己脑补。

**现实：**

Variable 文档里说得很清楚：

* `var:` / `global_var:` / `local_var:` 是 **事件目标类型（event target 类型）** ，可以作为 scope link 使用；
* `set_variable = { name = X ... }` 后，**变量名本身**就可以作为 script_value / trigger 的“左值”。

而你的实际测试也证明：

* 用 `var:gacha_total_rolls_count` 这类写法时，log 报的是：
  > Event target link 'var' returned an unset scope
  >
  > 说明引擎在尝试把 `var` 当成 event target link，用错上下文了。
  >

**现在的正确用法：**

* 在 script_value 里直接写变量名：

<pre class="overflow-visible!" data-start="2120" data-end="2186"><div class="contain-inline-size rounded-2xl relative bg-token-sidebar-surface-primary"><div class="sticky top-9"><div class="absolute end-0 bottom-0 flex h-9 items-center pe-2"><div class="bg-token-bg-elevated-secondary text-token-text-secondary flex items-center gap-4 rounded-sm px-2 font-sans text-xs"></div></div></div><div class="overflow-y-auto p-4" dir="ltr"><code class="whitespace-pre! language-txt"><span><span>add = { value = gacha_total_rolls_count multiply = 17 }
</span></span></code></div></div></pre>

* 在 trigger 里也是直接用变量名：

<pre class="overflow-visible!" data-start="2212" data-end="2263"><div class="contain-inline-size rounded-2xl relative bg-token-sidebar-surface-primary"><div class="sticky top-9"><div class="absolute end-0 bottom-0 flex h-9 items-center pe-2"><div class="bg-token-bg-elevated-secondary text-token-text-secondary flex items-center gap-4 rounded-sm px-2 font-sans text-xs"></div></div></div><div class="overflow-y-auto p-4" dir="ltr"><code class="whitespace-pre! language-txt"><span><span>limit = { gacha_constellation_lvl >= 6 }
</span></span></code></div></div></pre>

**结论：**

“在 EU5 里任何涉及变量都要写 `var:` / `local_var:`”这整套是幻觉。

你现在的版本（裸变量名 + 只在需要时才用 `<type>var:` 作为 scope link）是和文档、和实测一致的。

---

### 2.2 Gatekeeper 已经初始化，但 script_value 仍然报「没设变量」

这部分一开始我们怀疑“`has_variable` 不生效 / set_variable 没进存档”，后来发现幻觉在于 **初始化顺序** 。

**真实原因：**

* 早期版本里，`gacha_ensure_state_initialized` 没有在**所有路径上**优先执行：
  * interaction 触发事件；
  * 事件描述里（`desc = {...}`）引用了变量 / script value；
  * 描述 eval 时，变量还没被初始化。
* 于是 script_value 在 eval 的 callstack 里跑在 `gacha_events.1` 描述之前，导致：
  * `gacha_total_rolls_count` 未设；
  * `gacha_block_pity_met_bool` 未设；
  * 全套 log 爆炸。

你现在的修正版把  **初始化逻辑直接写进 `gacha_events_interaction.effect` 的 `scope:actor` 里** ，在 `trigger_event_non_silently = gacha_events.1` 之前执行，这样就完全稳定了。

所以这里的“幻觉”是： **以为 Gatekeeper 在别的地方总是会先跑一遍** ，实际没有保证这一点。

---

## 三、Scope / saved_scope 的幻觉

### 3.1 对 `save_scope_as` 生命周期的想当然

**早期假设：**

* “saved scope 是全局挂在某个对象上的，可以放心跨 event / 跨队列随便用”。

**文档实际只说了：**

* 变量可以保存 scope；
* 可以用 `clear_saved_scope = xxx` 清理；
* 没明确保证“所有 event 队列里一直可见、永不出问题”。

**我们现在采取的保守策略：**

* Wrapper 里只负责把角色存在 `gacha_last_pulled_char` 上；
* 事件自身的 `immediate` 立刻做一次快照：
  <pre class="overflow-visible!" data-start="3363" data-end="3492"><div class="contain-inline-size rounded-2xl relative bg-token-sidebar-surface-primary"><div class="sticky top-9"><div class="absolute end-0 bottom-0 flex h-9 items-center pe-2"><div class="bg-token-bg-elevated-secondary text-token-text-secondary flex items-center gap-4 rounded-sm px-2 font-sans text-xs"></div></div></div><div class="overflow-y-auto p-4" dir="ltr"><code class="whitespace-pre! language-txt"><span><span>immediate = {
      scope:gacha_last_pulled_char = {
          save_scope_as = gacha_event_target_char
      }
  }
  </span></span></code></div></div></pre>
* `after` 里**由事件自己**清掉：
  <pre class="overflow-visible!" data-start="3521" data-end="3648"><div class="contain-inline-size rounded-2xl relative bg-token-sidebar-surface-primary"><div class="sticky top-9"><div class="absolute end-0 bottom-0 flex h-9 items-center pe-2"><div class="bg-token-bg-elevated-secondary text-token-text-secondary flex items-center gap-4 rounded-sm px-2 font-sans text-xs"></div></div></div><div class="overflow-y-auto p-4" dir="ltr"><code class="whitespace-pre! language-txt"><span><span>after = {
      clear_saved_scope = gacha_event_target_char
      clear_saved_scope = gacha_last_pulled_char
  }
  </span></span></code></div></div></pre>

这样我们完全不依赖“跨 event 久期”的未文档行为，只用“触发瞬间 + 同一个事件作用域”的那一瞬间。

**结论：**

“可以无脑把 saved scope 当全局指针用”是幻觉，现在的设计是显式快照 + 显式清理。

---

### 3.2 `scope:actor` 到底是谁

**幻觉：**

* 按 CK3 记忆，interaction 里的 `scope:actor` 是“角色”。

**现实（你自己在游戏里验证过）：**

* 在 EU5 的 `*_interactions.txt` 里，这个 interaction 的 `scope:actor` 实际是  **国家 scope** ；
* 你在这个 scope 下用 `gold`、`set_variable`、`trigger_event_non_silently = gacha_events.1` 都正常。

这跟 Scope 文档里的“可以持有变量的 scope 列表（country/character/location/...）”也能对得上。

**结论：**

“interaction 里 actor 一定是 character”是 CK3 残留，现在以你实际观察为准：在这条 interaction 上，actor 是 country。

---

### 3.3 在 trigger 里把 effect 写法硬塞进去

你这段：

<pre class="overflow-visible!" data-start="4269" data-end="4354"><div class="contain-inline-size rounded-2xl relative bg-token-sidebar-surface-primary"><div class="sticky top-9"><div class="absolute end-0 bottom-0 flex h-9 items-center pe-2"><div class="bg-token-bg-elevated-secondary text-token-text-secondary flex items-center gap-4 rounded-sm px-2 font-sans text-xs"></div></div></div><div class="overflow-y-auto p-4" dir="ltr"><code class="whitespace-pre! language-txt"><span><span>if = {
    limit = { scope:existing_char = { employer = root } }
    ...
}
</span></span></code></div></div></pre>

**问题点：**

* `limit = { ... }` 块里是  **trigger 语法** ，不是 effect；
* `scope:existing_char = { ... }` 这种写法在 trigger 里是“把 existing_char 当成 scope，然后检查其中的条件”，语义是对的，但如果 existing_char 根本不存在，就直接炸；
* log 里已经给你看了：`Scoped object of type 'character' is not valid (角色“角色”(4294967295))`。

**文档推荐的安全写法是用 `?=`：**

<pre class="overflow-visible!" data-start="4650" data-end="4719"><div class="contain-inline-size rounded-2xl relative bg-token-sidebar-surface-primary"><div class="sticky top-9"><div class="absolute end-0 bottom-0 flex h-9 items-center pe-2"><div class="bg-token-bg-elevated-secondary text-token-text-secondary flex items-center gap-4 rounded-sm px-2 font-sans text-xs"></div></div></div><div class="overflow-y-auto p-4" dir="ltr"><code class="whitespace-pre! language-txt"><span><span>limit = {
    scope:existing_char ?= { employer = root }
}
</span></span></code></div></div></pre>

这等价于：

<pre class="overflow-visible!" data-start="4728" data-end="4829"><div class="contain-inline-size rounded-2xl relative bg-token-sidebar-surface-primary"><div class="sticky top-9"><div class="absolute end-0 bottom-0 flex h-9 items-center pe-2"><div class="bg-token-bg-elevated-secondary text-token-text-secondary flex items-center gap-4 rounded-sm px-2 font-sans text-xs"></div></div></div><div class="overflow-y-auto p-4" dir="ltr"><code class="whitespace-pre! language-txt"><span><span>limit = {
    exists = scope:existing_char
    scope:existing_char = { employer = root }
}
</span></span></code></div></div></pre>

所以这里的“幻觉”是： **以为 scope 永远存在、不需要做 exists / ?= 检查** 。

你现在把存在性检查用 `?=` 包进去之后，就不会再看到那种 “invalid object 4294967295” 的 spam 了。

---

## 四、UI / Illustration 相关的幻觉

### 4.1 “UI 会自动用 `gacha_event_target_char` 做立绘”

**幻觉：**

* 我一开始讲得有点“理所当然”：
  > “UI 会自动根据 saved scope `gacha_event_target_char` 显示立绘”
  >

这其实是从 CK3 的体验往 EU5 硬套。

**现实：**

* Event 文档讲的是 Illustration / Portrait 系统：
  * 对 pop 事件：前两个 saved pop scope 参与渲染；
  * 可以显式用 `event_illustration_estate_effect`、`image =` 等。
* 对角色立绘，目前 wiki 没有写“凡是叫 XXX 的 saved scope 就自动用来画人像”这样明确的规则。

**我们现在的状态：**

* 实际方案是：
  * 把角色存成一个 saved scope（例：`gacha_event_target_char`）；
  * 再通过 illustration（或者 UI data function）去读这个 scope 画画；
* “自动用这个名字的 scope”这件事本身是 **没有文档的假设** ，所以在正式报告里最好标为“基于测试的经验规则”，不要当官方 spec 写死。

---

## 五、还算正确但容易混淆的点（非幻觉，只是要记住边界）

这些不算“错”，但一开始没讲清楚，现在已经厘清：

1. **Gatekeeper 放在哪：**
   * Interaction 的 `effect` 里做一次全套 `has_variable` 初始化，是最安全的；
   * 内核 `gacha_execute_single_roll_silent` 里再调用一次 `gacha_ensure_state_initialized` 属于“多一重保险”，不会出错。
2. **`trigger_event_non_silently` 的同步 / 异步：**
   * 事件本体（option/desc）是放到 UI 队列里慢慢弹；
   * 但是 `immediate = { ... }` 是在触发那一刻就跑，这也是我们“快照”模式的基础。
3. **`var:` / `local_var:` 什么时候还能用：**
   * 按 Variable 文档，它们在作为“事件目标链接”时是合法的，例如：

     `set_variable = { name = foo value = this }` 后，可以 `foo:some_effect = { ... }` 之类的用法；
   * 但在你当前这套 gacha 系统里，所有地方都只需要“变量的数值”，裸名字就够了，没必要碰 `<type>var:` 这套复杂度。
